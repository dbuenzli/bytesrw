{0 Bytesrw {%html: <span class="version">%%VERSION%%</span>%}}

Bytesrw extends the OCaml {!Bytes} module with composable, memory
efficient, byte stream {{!Bytesrw.Bytes.Reader}readers} and
{{!Bytesrw.Bytes.Writer}writers} compatible with effect based
concurrency.

Except for byte slice {{!Bytesrw.Bytes.Slice.validity}life-times},
these abstractions intentionally separate away ressource management
and the specifics of reading and writing bytes.

{1:manuals Manuals}

The following manuals are available:

{ul
{- The {{!quick}quick start} should get you started}
{- The {{!tutorial}tutorial} shows you how to devise your own
   stream processors}
{- The {{!conventions}conventions} are conventions to follow
   if you write byte stream reader and writed based codecs}}

{1:bytesrw Library [bytesrw]}

This library has the base definition of bytes
reader and writers as an extension of the {!Stdlib.Bytes}
module.

{!modules:
Bytesrw}

{!modules:
Bytesrw.Bytes.Slice
Bytesrw.Bytes.Stream
Bytesrw.Bytes.Reader
Bytesrw.Bytes.Writer}

{1:bytesrw_kit Library [bytesrw.kit]}

The following modules rely only the [Stdlib]:

{!modules:
Bytesrw_utf}

{1:bytesrw_compress Libraries [bytesrw.{zlib,zstd}]}

Each of these modules lives in its corresponding
library and depends on their canonical C library.

{!modules:
Bytesrw_zlib
Bytesrw_zstd
}

{1:quick Quick start}

{1:todo TODO}

{ul
{- Add signatures for filters and perhaps a function
   to easily apply a filter form string to string.}
{- [Bytesrw_unix].}
{- Small howto and a simple tutorial to devise your own. Show read
   sniffing.}
{- [Bytesrw_zstd], add per frame control,
   figure out the mulithreaded compression support (we'd need to copy
   the bytes). Decide whether to add simple direct funs on [string].}
{- [Slice], add bigbytes converters.}
{- We could add an hmap to readers and writers. But let's KISS for now.}
{- Push backs. Should we disallow pushing back to a negative position (in
   which case {!Bytesrw.Bytes.Reader.empty} can become a value again) ?
   We might want to push a header before a stream. But then we should
   provide {!Bytesrw.Bytes.Reader.val-append} at some point.}
{- Readers. Should we provide an interface for specifying the number
   of bytes to read ? That would entail storing last read in the reader.
   But then if too much is requested then either a) we
   need to start buffering internally b) We potentially return less,
   like `read` and you need to make your own buffering again.
   Perhaps it's better to keep the low level we have now.}
{- In the end I'm not so sure [parent_pos] makes that much
   sense. In a lot of cases it seems easy to make it report nonsense (e.g. when
   concatenating) besides I'm not sure one level is enough. Maybe
   the call stack is what we need hereâ€¦}
{- On stream cuts. When we cut streams we raise [Invalid_argument] if we try to
   consume the right part before the left returned [eod]. We could try to add
   a sync mecanism, it would default to raise, but you could plug it with
   a blocking effect.}}

See also the {{!page-notes}design notes}.
