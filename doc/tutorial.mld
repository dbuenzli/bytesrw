{0 Bytes reader and writer tutorial}

See also the {{!page-index.quick}quick start} for short, self-contained,
code snippets.

In [bytesrw] you never get to manipulate bytes streams directly. You
observe finite parts of them via stream readers and writers. These
finite parts are represented by {{!Bytesrw.Bytes.Slice}slices} which
are non-empty, consecutive, subranges of {!Bytes.t} values. There is a
single, distinguished, empty slice {!Bytesrw.Bytes.Slice.eod} which is
used to denote the end of stream. Once this value is seen no more
bytes can be observed from a stream.

So for [bytesrw] a byte stream is a sequence of {!Bytesrw.Bytes.Slice.t}
values ended by a {!Bytesrw.Bytes.Slice.eod} value. Bytes reader and writers
give you two different ways of observing this sequence, in order, but always
only slice by slice:

- With byte readers you get to pull from the sequence enumerated by
  the reader's slice enumerating function until {!Bytesrw.Bytes.Slice.eod}
  is pulled.
- With byte writers you get to see slices pushed on the writer
  in the writer's slice iteration function until {!Bytesrw.Bytes.Slice.eod}
  is pushed.

{1:readers Stream readers}

Stream {{!Bytesrw.Bytes.Reader}readers} are pull abstractions. They
provide access to the slices of a stream, in order, on demand, but
only slice by slice: the slice you get from a reader [r] on
{!Bytesrw.Bytes.Reader.read} is {{!Bytesrw.Bytes.Slice.validity}valid
for reading} only until the next slice is read from [r].

This means that you are {b only} allowed to read those bytes in the range
defined by the slice until the next call to
{!Bytesrw.Bytes.Reader.read} on [r]. You are not even allowed
to mutate the bytes in the range of the slice. If you need to keep the
data for longer or want to modify it, you need to copy it.

Readers can be created from {{!Bytesrw.Bytes.Reader.of_bytes} bytes},
{{!Bytesrw.Bytes.Reader.of_string}strings},
{{!Bytesrw.Bytes.Reader.of_slice}slices},
{{!Bytesrw.Bytes.Reader.of_in_channel} input channels},
{{!Bytesrw_unix.bytes_reader_of_fd}file descriptors}, etc. More generally
{{!Bytesrw.Bytes.Reader.make}any function} that enumerates a stream's slices
can be turned into a bytes reader.

Readers maintain an informative stream position accessible with
{!Bytesrw.Bytes.Reader.pos}. The position is the zero based-index of
the next byte to read or, alternatively, the
{{!Bytesrw.Bytes.Reader.read_length} number of bytes} that have been
returned by calls to {!Bytesrw.Bytes.Reader.read}. Positions can be used
for statistics and for locating errors.

Readers have an informative {!Bytesrw.Bytes.Reader.slice_length}
property. It is a {b hint} on the maximal length of slices that it
returns. This can be used by reader consumers to adjust their own
buffers.

{2:reader_push_back Push backs}

Reader {{!Bytesrw.Bytes.Reader.push_back}push backs} provide a limited
form of look ahead. They should not be used as a general buffering
mecanism but they allow to {{!Bytesrw.Bytes.Reader.sniff}sniff stream
content} (for example to {{!Bytesrw_utf.guess_reader_encoding}guess
encodings}) in order to invoke designated decoders and to break
streams into substreams at precise positions when substream lengths may
not be known before actually consuming them.

{2:reader_filters Reader filters}

{{!Bytesrw.Bytes.Reader.filters}Reader filters} are reader
transformers. They take a reader [r] and return a new reader which, when
read, reads on [r] and transforms its slices. For example given a
reader [r] that returns compressed bytes a decompress filter like
{!Bytesrw_zstd.decompress_reads} returns a new reader which reads and
decompresses the slices of [r].

Filters do not necessarily act on a reader forever. For example
{!Bytesrw_zstd.decompress_reads} if invoked with [all_frames:false]
decompresses a single [zstd] frame, after that [r] can be used again
to read other kind of data.

{2:reader_limits Reader limits}

The number of bytes returned by a reader can be limited with
{!Bytesrw.Bytes.Reader.limit}. See {{!page-index.limiting}this example}
in the quick start.

{1:writers Stream writers}

{1:positions Stream positions}

For many usages stream positions are irrelevant. However one should
pay attention to them when devising readers and writers so that errors
are reported accurately.

Byte reader and writers maintain a stream position which is the
zero-based index of the next byte to read or write. This value
can also be intepreted as the number of bytes that have been
read or written.

{1:read_filters Understanding read filters}

The conventions are described in {!Bytesrw.Bytes.Reader.filter}

{1:write_filter Understanding write filters}

Explain the behaviour about {!Bytesrw.Bytes.Slice.eod}.
The conventions are described in {!Bytesrw.Bytes.Writer.filter}
