{0 Bytesrw {%html: <span class="version">%%VERSION%%</span>%}}

Bytesrw extends the OCaml {!Bytes} module with composable, memory
efficient, byte stream {{!Bytesrw.Bytes.Reader}readers} and
{{!Bytesrw.Bytes.Writer}writers} compatible with effect based
concurrency.

Except for byte slice {{!Bytesrw.Bytes.Slice.validity}life-times},
these abstractions intentionally separate away ressource management
and the specifics of reading and writing bytes.

{1:bytesrw Library [bytesrw]}

{!modules:
Bytesrw
}
{!modules:
Bytesrw.Bytes.Slice
Bytesrw.Bytes.Reader
Bytesrw.Bytes.Writer}

{1:bytesrw_zlib Library [bytesrw.zlib]}

{!modules:
Bytesrw_zlib
}

{1:bytesrw_zstd Library [bytesrw.zstd]}

{!modules:
Bytesrw_zstd
}


{1:todo TODO}

{ul
{- Use size maybe ? But size is never used by the stdlib.}
{- Make a decision on whether [?slice_length] on readers and writers are
   hints or hard limits. If it is a hard limit, the abstraction could
   transparently adapt the size of slices. But then we could also
   simply provide reslice combinators for those clients that want
   the guarantees.}
{- Reader and writer, sneak over the data and mutate the read/write
   function when [eod] has been seen ? Could be benificial not to
   keep references on these closures. For readers this could also be
   used to implement push back without having to create a new reader.}
{- Not calling stuff after [Slice.eod] (rather than allowing
   more calls with [Slice.eod]) is likely a better idea,
   e.g. we don't want to flush a possibly closed fd.}
{- [Bytesrw_unix].}
{- Small howto and a simple tutorial to devise your own.}
{- Sort out the [stream_offset] and \{[written],[read]\}[_length] system,
   so that it can be reliable and not painful to work with. Idea:
   transformers should always offset from the structure they transform.
   Allow to change the values but as a new value (that way if we give
   access to their own value to reader/writer they can't fiddle with the
   counts.)}
{- Sort out an error convention. If we give access to the reader
   and writer in the functions
   then it could be [exception M.Error of Bytes.processor option * 'a].
   Does this open a can of worm ? Self-writes and reads.}
{- [Bytesrw_zstd], add per frame control,
   figure out the mulithreaded compression support (we'd need to copy
   the bytes), add stream offsets to errors.}
{- Possibly we could add an hmap to readers and writers. But let's KISS
   for now.}}
