{0 Bytesrw {%html: <span class="version">%%VERSION%%</span>%}}

Bytesrw extends the OCaml {!Bytes} module with composable, memory
efficient, byte stream {{!Bytesrw.Bytes.Reader}readers} and
{{!Bytesrw.Bytes.Writer}writers} compatible with effect based
concurrency.

Except for byte slice {{!Bytesrw.Bytes.Slice.validity}life-times},
these abstractions intentionally separate away ressource management
and the specifics of reading and writing bytes.

{1:manuals Manuals}

The following manuals are available:

{ul
{- The {{!quick}quick start} should get you started}
{- The {{!tutorial}tutorial} shows you how to devise your own
   stream processors}
{- The {{!conventions}conventions} are conventions to follow
   if you write byte stream reader and writed based codecs}}

{1:bytesrw Library [bytesrw]}

This library has the base definition of bytes
reader and writers as an extension of the {!Stdlib.Bytes}
module.

{!modules:
Bytesrw}

{!modules:
Bytesrw.Bytes.Slice
Bytesrw.Bytes.Stream
Bytesrw.Bytes.Reader
Bytesrw.Bytes.Writer}

{1:bytesrw_kit Library [bytesrw.kit]}

The following modules rely only the [Stdlib]:

{!modules:
Bytesrw_utf}

{1:bytesrw_other_libs Libraries [bytesrw.{unix,zlib,zstd}]}

Each of these modules lives in its corresponding library.
Compression libraries depend on their canonical C library.

{!modules:
Bytesrw_unix
Bytesrw_zlib
Bytesrw_zstd
}

{1:quick Quick start}

{1:todo TODO}

{ul
{- [Bytesrw_unix].}
{- Small howto and a simple tutorial to devise your own. Show read
   sniffing.}
{- [Bytesrw_zstd], add per frame control,
   figure out the mulithreaded compression support (we'd need to copy
   the bytes). Decide whether to add simple direct funs on [string].}
{- [Slice], add bigbytes converters.}
{- We could add an hmap to readers and writers. But let's KISS for now.}
{- Push backs. Should we disallow pushing back to a negative position (in
   which case {!Bytesrw.Bytes.Reader.empty} can become a value again) ?
   We might want to push a header before a stream. But then we should
   provide {!Bytesrw.Bytes.Reader.val-append} at some point.}
{- Readers. Should we provide an interface for specifying the number
   of bytes to read ? That would entail storing last read in the reader.
   But then if too much is requested then either a) we
   need to start buffering internally b) We potentially return less,
   like `read` and you need to make your own buffering again.
   Perhaps it's better to keep the low level we have now.}
{- On stream cuts. When we cut streams we raise [Invalid_argument] if we try to
   consume the right part before the left returned [eod]. We could try to add
   a sync mecanism, it would default to raise, but you could plug it with
   a blocking effect.}
{- Review slice_length propagation, everywhere.}
{- Review tracing.}
{- What should we do with channel/unix reader/writer exceptions
   convert their exceptions to Bytes.Stream.Error or not ?}
}

See also the {{!page-notes}design notes}.
